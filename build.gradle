// build.gradle
import groovy.json.JsonSlurper
import net.fabricmc.loom.task.RemapJarTask
import java.io.ByteArrayOutputStream

plugins {
    id 'systems.manifold.manifold-gradle-plugin' version "${manifold_plugin_version}"
    id 'fabric-loom' version "${loom_version}"
    id 'maven-publish'
    id 'com.gradleup.shadow' version '9.0.0-beta15'
    id 'com.modrinth.minotaur' version '2.+'
}

ext.cachedJdList = null


version = project.mod_version
group = project.maven_group

base {
    archivesName = project.archives_base_name
}

// -------------------- VERSION HANDLING --------------------
def generateMcVersionMacros(List<String> versions, int selectedIndex) {
    def sb = new StringBuilder("# DON'T TOUCH THIS FILE, This is handled by the build script\n")
    versions.eachWithIndex { v, i ->
        sb << "MC_${v.replace('.', '_')}=${i}\n"
        if (i == selectedIndex) sb << "MC_VER=${i}\n"
    }
    if (project.mod_version.toLowerCase().contains("dev")) sb << "DEV_BUILD=\n"
    new File(project.projectDir, "build.properties").text = sb.toString()
    println "üìù build.properties geschrieben mit ${versions.size()} Versionen (MC_VER=${selectedIndex})"
}

static def parseVersion(String v) {
    def parts = v.tokenize('.').collect { it.toInteger() }
    while (parts.size() < 3) parts += 0
    return parts[0] * 10000 + parts[1] * 100 + parts[2]
}

static def getJavaVersionForMinecraft(String mcVersion) {
    def v = parseVersion(mcVersion)
    if (v >= parseVersion("1.21.0")) return JavaVersion.VERSION_21
    if (v >= parseVersion("1.20.0")) return JavaVersion.VERSION_17
    if (v >= parseVersion("1.17.0")) return JavaVersion.VERSION_16
    return JavaVersion.VERSION_1_8
}

def effectiveJavaVersion = getJavaVersionForMinecraft(project.minecraft_version)


tasks.register('generatePreprocessorDefinitions') {
    doLast {
        def mcVersion = project.minecraft_version
        def parsed = new JsonSlurper().parse(new URL("https://meta.fabricmc.net/v2/versions/game"))
        def versions = parsed.findAll { it.stable }*.version.sort { a, b ->
            def norm = { it.tokenize('.').collect { it.padLeft(2, '0') }.join('').toInteger() }
            norm(a) <=> norm(b)
        }
        def index = versions.indexOf(mcVersion)
        if (index == -1) throw new GradleException("‚ùå Minecraft-Version ${mcVersion} ist kein bekannter Fabric-Release.")
        generateMcVersionMacros(versions, index)
    }
}
tasks.named("compileJava") { dependsOn generatePreprocessorDefinitions }

// -------------------- MANIFOLD COMPILER ARGS --------------------
tasks.withType(JavaCompile).configureEach {
    def mcVer = project.minecraft_version
    def macro = "MC_" + mcVer.replace('.', '_')
    def versionInt = mcVer.tokenize('.').collect { it.padLeft(2, '0') }.join('').toInteger()
    //   println "üì¶ Setze Manifold: ${macro} (int: ${versionInt})"

    def parsed = new JsonSlurper().parse(new URL("https://meta.fabricmc.net/v2/versions/game"))
    def versions = parsed.findAll { it.stable }*.version

    def toInt = { version ->
        def parts = version.tokenize('.')
        while (parts.size() < 3) parts += '0'
        def padded = parts.collect { it.toString().padLeft(2, '0') }
        return padded.join('').toInteger()
    }
    def defines = versions.collect { ver ->
        def versionMacro = "MC_" + ver.replace('.', '_')
        def intVal = toInt(ver)
        //println " - ${versionMacro} = ${intVal}"
        return "-A${versionMacro}=${intVal}"
    }

    options.compilerArgs += ["-Xplugin:Manifold",
                             "-AMC_VER=${versionInt}",
                             //    "-AMC_VER_INT=${versionInt}",
                             "-Xlint:unchecked",
                             "-Xlint:deprecation"] + defines

    options.release = Integer.parseInt(effectiveJavaVersion.majorVersion)
}

// -------------------- DEPENDENCY RESOLUTION --------------------
def resolveFabricVersions(String mcVersion) {
    if (project.ext.cachedJdList == null) {
        println "üåê Lade jdlist.txt von Fabric Maven..."
        project.ext.cachedJdList = new URL("https://maven.fabricmc.net/jdlist.txt").text.readLines()
    } else {
        println "‚ö° Verwende gecachte jdlist.txt"
    }

    def jdList = project.ext.cachedJdList

    def loader = new JsonSlurper().parse(new URL("https://meta.fabricmc.net/v2/versions/loader/${mcVersion}"))[0].loader.version

    def parseVersion = { String str -> str.tokenize('.+-').collect { token -> token.isNumber() ? token.toInteger() : token }
    }

    def api = jdList.findAll {
        it.startsWith("fabric-api-") && it.endsWith("+${mcVersion}")
    }*.replace("fabric-api-", "")
            .max { a, b ->
                def va = parseVersion(a)
                def vb = parseVersion(b)
                for (int i = 0; i < Math.max(va.size(), vb.size()); i++) {
                    def ai = i < va.size() ? va[i] : 0
                    def bi = i < vb.size() ? vb[i] : 0
                    if (ai instanceof Number && bi instanceof Number) {
                        if (ai != bi) return ai <=> bi
                    } else {
                        return ai.toString() <=> bi.toString()
                    }
                }
                return 0
            }

    return [loader: loader, api: api]
}


def resolved = resolveFabricVersions(project.minecraft_version)
ext.loader_version = resolved.loader
ext.fabric_version = resolved.api

// -------------------- DEPENDENCIES --------------------
dependencies {
    annotationProcessor "systems.manifold:manifold-preprocessor:${rootProject.manifold_version}"
    minecraft "com.mojang:minecraft:${project.minecraft_version}"
    mappings loom.officialMojangMappings()
    modImplementation "net.fabricmc:fabric-loader:${loader_version}"
    modImplementation "net.fabricmc.fabric-api:fabric-api:${fabric_version}"

    if (project.minecraft_version.startsWith("1.16")) {
        implementation "org.slf4j:slf4j-api:1.7.36"
        runtimeOnly "org.slf4j:slf4j-simple:1.7.36"
        println "üì¶ SLF4J f√ºr Minecraft ${project.minecraft_version} aktiviert"
    }
    implementation "net.minestom:minestom:2025.07.30-1.21.8"
    implementation "dev.hollowcube:polar:1.14.6"
    shadow "net.minestom:minestom:2025.07.30-1.21.8"
    shadow "dev.hollowcube:polar:1.14.6"

}

repositories {
    // Additional repositories can be declared here
    mavenCentral()
}

manifold {
    manifoldVersion = rootProject.manifold_version
}
shadowJar {
    //minimize()
    configurations = [project.configurations.shadow]
}


tasks.register('remappedShadowJar', RemapJarTask) {
    dependsOn shadowJar
    group = "build"
    description = "Remap the Shadow JAR"

    input.set(shadowJar.archiveFile)
    addNestedDependencies.set(true)
}


tasks.assemble.dependsOn tasks.remappedShadowJar

processResources {
    inputs.property "version", project.version
    filesMatching("fabric.mod.json") {
        expand(["version"          : project.version,
                "mod_id"           : project.mod_id,
                "mod_name"         : project.mod_name,
                "mod_description"  : project.mod_description,
                "icon_path"        : project.icon_path,
                "minecraft_version": project.minecraft_version,
                "license_type"   : project.license_type,
        ])
    }
}

java {
    withSourcesJar()
    sourceCompatibility = effectiveJavaVersion
    targetCompatibility = effectiveJavaVersion
}

jar {
    from(sourceSets.main.output) {
        include 'net/kyori/**'
        include 'net/minestom/**'
        include 'dev/hollowcube/**'
    }
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    } {
        include 'META-INF/services/**'
        include 'net/kyori/**'
        include 'net/minestom/**'
        include 'dev/hollowcube/**'
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }

    inputs.property "archivesName", project.base.archivesName
    from("LICENSE.md") { rename { "${it}_${inputs.properties.archivesName}" } }

    // Dynamischer JAR-Dateiname basierend auf MC- und Mod-Version
    archiveFileName = "${archives_base_name}-${minecraft_version}+${mod_version}.jar"
}


publishing {
    publications {
        create("mavenJava", MavenPublication) {
            artifactId = project.archives_base_name
            from components.java
        }
    }
    repositories {
        // Define publishing destinations here
    }
}
def isWindows = System.getProperty("os.name").toLowerCase().contains("win")
def gradleCommand = isWindows ? "gradlew.bat" : "./gradlew"

tasks.register('buildAllVersions') {
    doLast {
        def minVersion = project.hasProperty("buildFromVersion") ? project.buildFromVersion : "1.0.0"
        def minInt = parseVersion(minVersion)

        def jdList = project.ext.cachedJdList ?: new URL("https://maven.fabricmc.net/jdlist.txt").text.readLines()
        project.ext.cachedJdList = jdList

        def rawVersions = new JsonSlurper()
                .parse(new URL("https://meta.fabricmc.net/v2/versions/game"))
                .findAll { it.stable }
                .collect { it.version }
                .findAll { ver ->
                    def versionInt = parseVersion(ver)
                    return versionInt >= parseVersion(minVersion) &&
                    jdList.any { it.startsWith("fabric-api-") && it.endsWith("+${ver}") }
                }
                .sort { -parseVersion(it) }


        def filtered = rawVersions.findAll { parseVersion(it) >= minInt }
                .sort { -parseVersion(it) }

        println "üöÄ Baue f√ºr folgende Minecraft-Versionen (>= ${minVersion}) in absteigender Reihenfolge:"
        filtered.each { println " - ${it}" }

        def outputDir = new File(project.projectDir, "out")
        outputDir.mkdirs()

        filtered.each { mcVer ->
            println "\n‚öôÔ∏è Baue f√ºr $mcVer..."
            def result = exec {
                workingDir = project.projectDir
                environment "minecraft_version", mcVer
                commandLine gradleCommand, "clean", "build", "shadowJar", "-Pminecraft_version=$mcVer"
                ignoreExitValue = true
            }
            if (result.exitValue != 0) {
                println "‚ùå Fehler beim Bauen f√ºr ${mcVer}, √ºberspringe..."
                return
            }

            // Eingangsdatei: mod-template-<version>-all-remapped.jar
            def fromName = "${archives_base_name}-${mod_version}.jar"
            def sourceFile = file("build/libs/${fromName}")
            def targetName = "${archives_base_name}-${mcVer}+${mod_version}.jar"
            def targetFile = new File(outputDir, targetName)

            if (sourceFile.exists()) {
                println "üì§ Kopiere ${fromName} ‚Üí ${targetName}"
                sourceFile.renameTo(targetFile)
            } else {
                println "‚ö†Ô∏è ${fromName} wurde nicht gefunden ‚Äì Build war evtl. leer."
            }
        }

        println "\n‚úÖ Alle Shadow-Builds gespeichert unter: ${outputDir.absolutePath}"
    }
}

def generateChangelog = {
    def proc = ['git', 'log', '--pretty=format:- %s', '--no-merges', '-n', '10'].execute()
    proc.waitFor()
    def output = proc.in.text.trim()
    return output ?: "No recent changes."
}

modrinth {
    syncBodyFrom = rootProject.file("README.md").text
    token = System.getenv("MODRINTH_TOKEN")
    projectId = project.modrinth_projectId
    versionNumber = project.mod_version
    versionName = "${archives_base_name}-${minecraft_version}+${mod_version}"
    versionType = project.mod_version_type
    uploadFile = shadowJar
    gameVersions = ["${project.minecraft_version}"]
    loaders = ["fabric"]
    dependencies {
        required.project "fabric-api"
    }
    changelog = "üîÑ Changes:\n${generateChangelog()}"
}